{"ast":null,"code":"\"use strict\";\n/* eslint-disable react/prop-types */\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar react_1 = __importDefault(require(\"react\"));\n\nvar isServerRenderResult_1 = __importDefault(require(\"./isServerRenderResult\"));\n/**\n * Logic to either call the renderFunction or call React.createElement to get the\n * React.Component\n * @param options\n * @param options.componentObj\n * @param options.props\n * @param options.domNodeId\n * @param options.trace\n * @param options.location\n * @returns {ReactElement}\n */\n\n\nfunction createReactOutput(_a) {\n  var componentObj = _a.componentObj,\n      props = _a.props,\n      railsContext = _a.railsContext,\n      domNodeId = _a.domNodeId,\n      trace = _a.trace,\n      shouldHydrate = _a.shouldHydrate;\n  var name = componentObj.name,\n      component = componentObj.component,\n      renderFunction = componentObj.renderFunction;\n\n  if (trace) {\n    if (railsContext && railsContext.serverSide) {\n      console.log(\"RENDERED \" + name + \" to dom node with id: \" + domNodeId);\n    } else if (shouldHydrate) {\n      console.log(\"HYDRATED \" + name + \" in dom node with id: \" + domNodeId + \" using props, railsContext:\", props, railsContext);\n    } else {\n      console.log(\"RENDERED \" + name + \" to dom node with id: \" + domNodeId + \" with props, railsContext:\", props, railsContext);\n    }\n  }\n\n  if (renderFunction) {\n    // Let's invoke the function to get the result\n    if (trace) {\n      console.log(name + \" is a renderFunction\");\n    }\n\n    var renderFunctionResult = component(props, railsContext);\n\n    if (isServerRenderResult_1[\"default\"](renderFunctionResult)) {\n      // We just return at this point, because calling function knows how to handle this case and\n      // we can't call React.createElement with this type of Object.\n      return renderFunctionResult;\n    }\n\n    if (react_1[\"default\"].isValidElement(renderFunctionResult)) {\n      // If already a ReactElement, then just return it.\n      console.error(\"Warning: ReactOnRails: Your registered render-function (ReactOnRails.register) for \" + name + \"\\nincorrectly returned a React Element (JSX). Instead, return a React Function Component by\\nwrapping your JSX in a function. ReactOnRails v13 will throw error on this, as React Hooks do not\\nwork if you return JSX. Update by wrapping the result JSX of \" + name + \" in a fat arrow function.\");\n      return renderFunctionResult;\n    } // If a component, then wrap in an element\n\n\n    var reactComponent = renderFunctionResult;\n    return react_1[\"default\"].createElement(reactComponent, props);\n  } // else\n\n\n  return react_1[\"default\"].createElement(component, props);\n}\n\nexports[\"default\"] = createReactOutput;","map":null,"metadata":{},"sourceType":"module"}